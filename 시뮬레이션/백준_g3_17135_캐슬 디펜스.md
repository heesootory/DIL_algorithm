# 17135 - ìºìŠ¬ ë””íœìŠ¤


## ì•„ì´ë””ì–´

* ì£¼ì˜í• ì !!!ğŸ¯
    - ê¶ìˆ˜ëŠ” ë™ì‹œì— í•œ ì ì„ ì ìˆ˜ë„ìˆë‹¤!!!

> ë‚´ê°€ êµ‰ì¥íˆ í—¤ë§¨ êµ¬ê°„ì´ë‹¤. ë³„ì˜ë¯¸ ì—†ì´ ë°›ì•„ë“¤ì´ê³  ë¬¸ì œë¥¼ í’€ì—ˆëŠ”ë°,
ë™ì‹œì— í•œì ì„ ì ìˆ˜ ìˆê²Œ ë˜ë©´, ë‹µì´ í¬ê²Œ ë‹¬ë¼ì§€ê²Œ ëœë‹¤.
ê¶ìˆ˜ëŠ” ê°€ì¥ ê°€ê¹Œìš°ë©´ì„œ ì™¼ìª½ì— ìˆëŠ” ì ì„ ì˜ê²Œ ë˜ëŠ”ë°, ê·¸ ì ì´ ë‹¤ë¥¸ ê¶ìˆ˜ê°€ ì´ë¯¸ ì´ë²„ë ¤ì„œ ì œì™¸í•´ë²„ë¦¬ëŠ”ê²Œ ì•„ë‹ˆë¼, ë‘ ê¶ìˆ˜ê°€ ëª¨ë‘ í•˜ë‚˜ì˜ ì ì„ ì˜ê²Œ ë˜ë¯€ë¡œ, cntì˜ ê°¯ìˆ˜ê°€ ëœ ì„¸ê²Œ ëœë‹¤.

* ìœ„ì˜ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸°ìœ„í•´ì„œ, ê¶ìˆ˜ê°€ ì˜ìë§ˆì ë§µì—ì„œ ëª¬ìŠ¤í„°ë¥¼ 1 -> 0ìœ¼ë¡œ ë°”ê¾¸ì§€ ì•Šê³ , ì¼ë‹¨ ê°€ì¥ ê°€ê¹Œìš°ë©´ì„œ ì™¼ìª½ì— ìˆëŠ” ì ë“¤ì„ ê¶ìˆ˜ë§ˆë‹¤ í•˜ë‚˜ì”© ë½‘ì€ë’¤, ê·¸ê²ƒì„ setì— ë„£ì–´ì„œ, setì‚¬ì´ì¦ˆë§Œí¼ë§Œ ì¹´ìš´íŠ¸ë¥¼ ì˜¬ë¦¬ê³ , ê·¸ setì§‘í•©ì— ìˆëŠ” ì ë“¤ë§Œ 0ìœ¼ë¡œ ë°”ê¿”ì£¼ì—ˆë‹¤.

* ê²°ë¡ ì€ ì‹¤í–‰í•˜ë©´ì„œ ìˆ˜í–‰ìˆœì„œì˜ ì°¨ì´ì¸ë°, í•­ìƒ ì§‘ì¤‘í•´ì„œ ê³ ë ¤í•  ì ì´ë‹¤.

* ì´ì™¸ì— ì „ì²´ì ì¸ ë¬¸ì œí’€ì´ì˜ ë°©í–¥ì€ ì¡°í•© + bfsíƒìƒ‰ìœ¼ë¡œ í’€ì—ˆë‹¤.

* ë¬¸ì œì—ì„œëŠ” ì ë“¤ì´ ë‚´ë ¤ì˜¤ê³ , ê¶ìˆ˜ê°€ ìˆëŠ” ì„±ì´ ê³ ì •ë˜ì–´ìˆëŠ”ë°, ì„±ì´ í•œì¹¸ì”© ì˜¬ë¼ê°€ëŠ” êµ¬í˜„ìœ¼ë¡œ í’€ì–´ëƒˆë‹¤.

## ğŸ³ ë°°ìš´ ìŠ¤í‚¬ ğŸ³

* setí•¨ìˆ˜ê°€ ë‚´ê°€ë§Œë“  Pair classë¥¼ ì¸ì‹í•˜ì§€ ëª»í•˜ë‹¤ëŠ” ì‚¬ì‹¤ì„ ë³µìŠµí•¨.

* setí•¨ìˆ˜ì— hashcodeë¥¼ ë¨¼ì € ì˜¤ë²„ë¼ì´ë”©í•˜ê³ , ê°™ì„ ê²½ìš°, equals í•¨ìˆ˜ë¥¼ í™•ì¸í•´ì„œ setì§‘í•©ì— ë„£ê¸° ë•Œë¬¸ì—, ë‘˜ë‹¤ êµ¬í˜„í•´ì£¼ì–´ì•¼ í•œë‹¤!!


## ì½”ë“œ

```java
import java.io.*;
import java.util.*;


public class Main {
    static class Pair implements Comparable<Pair>{
        int x, y;
        Pair(int x, int y){
            this.x = x;
            this.y = y;
        }
        @Override
        public int hashCode(){              // Pairë¥¼ setì§‘í•©ì—ì„œ êµ¬ë³„í•˜ê¸° ìœ„í•´ êµ¬í˜„
            return Objects.hash(x * 10 + y);
        }
        @Override
        public int compareTo(Pair o){
            return this.y - o.y;
        }
        @Override
        public boolean equals(Object obj){      // Pairë¥¼ setì§‘í•©ì—ì„œ êµ¬ë³„í•˜ê¸° ìœ„í•´ êµ¬í˜„
            if(obj instanceof Pair){
                return (this.x == ((Pair)obj).x) && (this.y == ((Pair)obj).y);
            }
            return false;
        }
    }
    static int N, M, D;
    static int[][] map;
    static int[] comb_arr = new int[3];
    static int[][] new_map;
    static int[] dx = {-1,0,0};
    static int[] dy = {0,-1,1};
    static int max_cnt;
    static int cnt;

    static void move(int line){         // ì„±ì´ í•˜ë‚˜ì”© ì˜¬ë¼ê°.
        new_map[line - 1] = new_map[line].clone();          // ê¶ìˆ˜ë“¤ì´ ìˆëŠ” ì„±ì„ í•œì¹¸ ì˜¬ë ¤ì„œ ë³µì‚¬í›„.
        Arrays.fill(new_map[line], 0);              // ì´ì „ ë¼ì¸ì„ ëª¨ë‘ 0ìœ¼ë¡œ ë¹„ì›€
    }

    static void archer_play(int line){      // í•œ ë¼ì¸ë§ˆë‹¤ ê¶ìˆ˜ë“¤ì´ ì£½ì´ëŠ” í”Œë ˆì´.
        Set<Pair> kill_list = new HashSet<>();
        for(int i = 0; i < M ; i++){
            if(new_map[line][i] == 2){
                boolean[][] visited = new boolean[N + 1][M];
                Queue<Pair> q = new LinkedList<>();
                q.add(new Pair(line, i));
                visited[line][i] = true;
                int range = 1;

                while(!q.isEmpty() && range <= D){
                    List<Pair> mon_list = new ArrayList<>();
                    int len = q.size();

                    for(int l = 0; l < len; l++){
                        Pair now = q.poll();

                        for(int d = 0; d < 3; d++){
                            int nx = now.x + dx[d];
                            int ny = now.y + dy[d];

                            if(nx < 0 || ny < 0 || ny >= M) continue;
                            if(visited[nx][ny]) continue;

                            visited[nx][ny] = true;
                            if(new_map[nx][ny] == 1) mon_list.add(new Pair(nx, ny));
                            // ì ì´ ìˆëŠ” ê²½ìš° ì¼ë‹¨ ë¦¬ìŠ¤íŠ¸ì— ì €ì¥. - ê°€ì¥ ê°€ê¹Œìš´ ì ë“¤ ì €ì¥.
                            q.add(new Pair(nx, ny));

                        }
                    }
                    range++;
                    if(mon_list.size() != 0){           // ì  ì ì´ í•˜ë‚˜ë¼ë„ ìˆë‹¤ë©´, sortë¥¼ ì´ìš©í•´ ê°€ì¥ ì™¼ìª½ ì ë¶€í„° ì •ë¦¬.
                        Collections.sort(mon_list);
                        Pair kill = mon_list.get(0);        // í•˜ë‚˜ë§Œ ë½‘ì•„ì„œ  
                        kill_list.add(kill);            // ë‹¤ì‹œ kill_listì— ì €ì¥
                        break;      // ê¶ìˆ˜ í•œëª…ë‹¹ í•œë§ˆë¦¬ë§Œ ì¡ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ì¡ì•˜ë‹¤ë©´ ë°”ë¡œ ë‹¤ìŒ ê¶ìˆ˜ì°¨ë¡€
                    }

                }
            }
        }
        // ì‹¤ì œ ì£½ì´ê¸°
        cnt += kill_list.size();        // setí•¨ìˆ˜ì— ì €ì¥ëœ ëª©ë¡ì˜ ì ë“¤ë§Œ ì¹´ìš´íŠ¸
        for(Pair p : kill_list) {
            new_map[p.x][p.y] = 0;      // ì ë“¤ 0ìœ¼ë¡œ ì²˜ë¦¬ - ì‹¤ì œ ì£½ìŒ
        }
    }

    static void play(){
        // ìƒˆë¡œìš´ ë°°ì—´ì— ë³µì‚¬
        new_map = new int[N + 1][M];
        for(int i = 0; i < N + 1; i++) new_map[i] = map[i].clone();
        // ê¶ìˆ˜ ë°°ì¹˜
        for(int i : comb_arr) new_map[N][i] = 2;

        // Ní„´ë§Œí¼ ê²Œì„ì´ ì§„í–‰.
        for(int n = N; n > 0; n--){
            // 1. ê¶ìˆ˜ ê³µê²© - bfs
            archer_play(n);
            // 2. ê¶ìˆ˜ ì´ë™. - ë°°ì—´ ë³µì‚¬
            move(n);
        }
    }

    static void comb(int idx, int start){       // ì¡°í•©ìœ¼ë¡œ ê¶ìˆ˜ ë°°ì¹˜
        if(idx == 3){
            cnt = 0;
            play();
            max_cnt = Math.max(max_cnt, cnt);
            return;
        }

        for(int i = start; i < M; i++){
            comb_arr[idx] = i;
            comb(idx + 1, i + 1);
        }
    }


    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        D = Integer.parseInt(st.nextToken());

        map = new int[N + 1][M];        // N ë¼ì¸ì— ê¶ìˆ˜ ë°°ì¹˜.

        for(int i = 0 ; i < N; i++){
            st = new StringTokenizer(br.readLine());
            for(int j = 0; j < M; j++){
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }
        Arrays.fill(map[N], 0);
        comb(0,0);
        System.out.println(max_cnt);
    }
}

```