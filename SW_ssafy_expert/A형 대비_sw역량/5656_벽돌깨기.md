# 5656 - 벽돌깨기



## 아이디어

* 순열을 이용해, 맵의 열만큼크기인 W 중 N을 뽑아 가장위를 공격해보는 dfs 탐색.
    - 백트래킹으로 맵을 지우고, 다시 그리기 어렵다 판단하여, 가지의 노드마다 배열을 복사하여, 모든 경우로 뻗어나가기 전에 새로운배열을 들고 진행한다.

* 블록이 폭발하는 과정 또한 dfs로 재귀를 타서 모든 블록을 부심.

* 맵 정리는 인덱스를 잘 계산하여 정리!




## 코드

```java
import java.io.*;
import java.util.*;


public class Solution {
    static int N, W, H;
    static int[] dx = {-1,1,0,0};
    static int[] dy = {0,0,-1,1};
    static int min = Integer.MAX_VALUE;

    static void clean_map(int[][] arr){     // 블록을 전부 밑으로 정리.
        for(int c = 0; c < W; c++){
            int idx  = -1;   // 자리 있는 인덱스
            for(int r = H - 1; r >= 0; r--){
                if(idx < 0){
                    if(arr[r][c] == 0) idx = r;
                }
                else{
                    if(arr[r][c] != 0){
                        arr[idx][c] = arr[r][c];
                        arr[r][c] = 0;
                        idx--;
                    }
                }
            }
        }
    }

    static void explose(int[][] arr, int x, int y){
        int len = arr[x][y];
        arr[x][y] = 0;
        for(int d = 0; d < 4; d++){
            int l = 1;
            int nx = x;
            int ny = y;
            while(l++ < len){
                nx += dx[d];
                ny += dy[d];
                if(nx < 0 || ny < 0 || nx >= H || ny >= W) break;
                if(arr[nx][ny] == 1) arr[nx][ny] = 0;
                else if(arr[nx][ny] > 1) explose(arr, nx, ny);      // 연속 폭발
            }

        }
    }

    static int[][] attack(int[][] arr, int col){       // 벽돌 부수기
        int sr = 0;
        for(int i = 0; i < H; i++) {
            if(arr[i][col] != 0){
                sr = i; break;
            }
        }
        explose(arr, sr, col);      // 폭발 시작
        clean_map(arr);             // 맵의 블록들 아래로 정리
        return arr;
    }

    static void dfs(int idx, int[][] arr){          // 순열로 구성해서, dfs 가지를 탐색.
        if(idx == N){
            int cnt = 0;
            for(int[] i : arr){
                for(int j : i) if(j != 0) cnt++;
            }
            if(cnt < min) min = cnt;
            return;
        }
        // 맵을 지우고, 다시 그리는 백트래킹이 상당히 어려움으로, 가지의 노드마다, 새로운 배열을 복사해서, 사용
        for(int i = 0; i < W; i++){
            int[][] test_arr = new int[H][W];
            for(int t = 0 ; t < H; t++) test_arr[t] = arr[t].clone();
            dfs(idx + 1, attack(test_arr, i));
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        int T = Integer.parseInt(br.readLine());
        for (int t = 1; t <= T; t++) {
            st = new StringTokenizer(br.readLine());

            N = Integer.parseInt(st.nextToken());
            W = Integer.parseInt(st.nextToken());
            H = Integer.parseInt(st.nextToken());
            min = Integer.MAX_VALUE;

            int[][] arr = new int[H][W];

            for(int i = 0; i < H; i++){
                st = new StringTokenizer(br.readLine());
                for(int j = 0; j < W; j++){
                    arr[i][j] = Integer.parseInt(st.nextToken());
                }
            }


            dfs(0, arr);
            System.out.printf("#%d %d\n", t, min);
        }
    }
}

```