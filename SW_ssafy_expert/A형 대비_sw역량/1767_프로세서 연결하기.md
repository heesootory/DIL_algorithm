# 1767 - 프로세서 연결하기


## 아이디어

* 결국 조합 + dfs(백트래킹) 문제이다.

* 처음에는 조합 + 부분집합 + 백트래킹 으로 풀었지만, 시간초과...
    - 🎯 부분집합의 경우를 모두 굳이 뽑은 다음에 백트래킹을 이용해서 연결해보는 것은 -> 단순히 백트래킹 코드 하나로 모두 가능한 작업이다.

* 연결을 시켜보고, 해제하는 과정에서, 재귀함수의 위아래로, connect함수 + disconnect함수를 따로 만들어서 어떻게든 해보려고 했지만, 불가능 했는데, 그 이유는 return 값이 2개 필요했기 때문이다.
    - 항상 함수를 만들어서 정리하고 싶다면, return의 갯수를 잘 생각해보는게 좋을 듯...
    - 여기서는 return값이 연결한 칸의 갯수, 배열이 둘다 필요하므로, 함수로 리펙토링하기 어려워 보인다.(혹시, 나중에 더 실력이 크면 가능할지도... ㅠ)


## 코드

```java
import java.io.*;
import java.util.*;

class Pair{
    int x, y;
    Pair(int x, int y){
        this.x = x;
        this.y = y;
    }
}
public class Solution {
    static int N;
    static List<Pair> core_list;        // 전체 코어 리스트
    static int total;           // 전체 코어 갯수
    static Pair[] core_arr;     // 조합으로 연결시킬 코어만 뽑은 배열
    static int[] dx = {-1,1,0,0};
    static int[] dy = {0,0,-1,1};
    static int min = Integer.MAX_VALUE;
    static boolean check;       // 최솟값을 찾았는지 여부

    static void dfs(int idx, int[][] arr, int sum){     // 4방향으로 연결 시켜보기 - 백트랙킹
        if(idx == core_arr.length){
            if(sum < min) {
                min = sum;
                check = true;       // 최솟값이 현재의 코어갯수에서 갱신되면, 표시
            }
            return;
        }
        // 연결시킬 코어 선택
        Pair core = core_arr[idx];
        for(int d = 0; d < 4; d++){

            boolean flag = true;        // 코어연결이 가능한지 여부
            int cnt = 0;        // 연결 갯수
            int nx = core.x;
            int ny = core.y;
            // 전선 그리기
            while(true){
                nx += dx[d];
                ny += dy[d];

                if(nx < 0 || ny < 0 || nx >= N || ny >= N) break;
                if(arr[nx][ny] == 1){
                    flag = false; break;
                }
                arr[nx][ny] = 1;
                cnt++;
            }
            // 이번 코어가 연결 가능하다면 다음코어도 ㄱㄱ.
            if(flag) dfs(idx + 1, arr, sum + cnt);

            // 연결 해제하기
            while(cnt-- > 0){
                nx -= dx[d];
                ny -= dy[d];
                arr[nx][ny] = 0;
            }

        }
    }
    static void comb(int idx, int start, int[][] arr){      // 뺄 코어를 조합으로 구해서, 뽑아보기 - 조합 + 백트랙
        if(idx == core_arr.length){
            dfs(0, arr, 0);
            return;
        }

        for(int i = start; i < core_list.size(); i++){
            core_arr[idx] = core_list.get(i);           // 조합을 통해 연결시키 코어를 갯수에 맞게 선택.
            comb(idx + 1, i + 1, arr);
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        int T = Integer.parseInt(br.readLine());
        for(int t = 1; t <= T; t++){
            N = Integer.parseInt(br.readLine());

            int[][] arr = new int[N][N];
            core_list = new ArrayList<>();
            check = false;
            min = Integer.MAX_VALUE;

            for(int i = 0; i < N; i++){
                st = new StringTokenizer(br.readLine());
                for(int j = 0; j < N; j++){
                    arr[i][j] = Integer.parseInt(st.nextToken());
                    if(arr[i][j] == 1 && i != 0 && j != 0 && i != N -1 && j != N-1)
                        core_list.add(new Pair(i, j));
                }
            }

            // 코어를 몇개 연결할 것인가
            total = core_list.size();
            for(int i = total; i > 0; i--){
                if(check) break;        // 이미 이전의 갯수에서 표시가 최솟값을 찾았었다면, 더이상 적은 갯수 탐색 ㄴ
                core_arr = new Pair[i];
                comb(0,0, arr);
            }

            if(min == Integer.MAX_VALUE) min = 0;       // 모서리에만 전부 있다면 0

            System.out.printf("#%d %d\n", t, min);

        }

    }

    static void print(int[][] arr){
        for(int[] i : arr){
            for(int j : i) System.out.print(j + " ");
            System.out.println();
        }
        System.out.println();
    }
}


```